# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    allowedFunctionsNotes.txt                          :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: amenses- <amenses-@student.42.fr>          +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2023/11/18 17:20:21 by amenses-          #+#    #+#              #
#    Updated: 2023/12/02 20:30:32 by amenses-         ###   ########.fr        #
#                                                                              #
# **************************************************************************** #

-spotchat server
-https://modern.ircdocs.horse/

man tcp(7)
A  newly created TCP socket has no remote or local address and is not fully specified.  To create an outgoing TCP connection use connect(2) to establish a connection to another TCP  socket.
To  receive new incoming connections, first bind(2) the socket to a local address and port and then call listen(2) to put the socket into the listening state.  After that a  new  socket  for each  incoming connection can be accepted using accept(2).  A socket which has had accept(2) or connect(2) successfully called on it is fully specified and may transmit data.  Data cannot  be transmitted on listening or not yet connected sockets

<netdb.h>

SERVER/CLIENT BACKGROUND [4]
Note that the client-server pair can speak SOCK_STREAM, SOCK_DGRAM, or anything else (as long as they’re speaking the same thing)
Often, there will only be one server on a machine, and that server will handle multiple clients using fork(). The basic routine is: server will wait for a connection, accept() it, and fork() a child process to handle it.

SOCKET [2, 3]
int socket(int *domain, int type, int protocol);

creates  an  endpoint  for communication and returns a file descriptor that refers to that endpoint
-domain: communication domain; this selects the protocol family which will be used for communication
    AF_INET (IPv4 Internet protocols, man ip(7));
    AF_INET6 (IPv6 Internet protocols, man ipv6(7));
    AF_UNIX (Local communication, =AF_LOCAL, man unix(7))
-type: specifies the communication semantics
    SOCK_STREAM (TCP)
    SOCK_DGRAM (UCP)
    SOCKET_RAW
-protocol: The protocol specifies a particular protocol to be used with the socket.  Normally only a  single  protocol  exists  to  support  a particular socket type within a given protocol family, in which case protocol can be specified as 0; man tcp(7)
-tcp_socket = socket(AF_INET, SOCK_STREAM, 0);
-Return: fd on success; -1 on failure

CLOSE [2]
int close(int socket);

Shuts down the socket associated with the socket descriptor sockfd, and frees resources allocated to the socket.
If socket refers to an open TCP connection, the connection is closed.
If a stream socket is closed when there is input data queued, the TCP connection is reset rather than being cleanly closed
Anyone attempting to read or write the socket on the remote end will receive an error [4]
-Return: 0 on success; -1 on failure

SETSOCKOPT [2, 3]
int setsockopt(int sockfd, int level, int option_name,
    const void *option_value, socklen_t option_length);

manipulate  options for the socket referred to by the file descriptor sockfd
-level: level at which the option resides and the name of the option
    SOL_SOCKET (at the sockets API level)
    IPPROTO_IP (at eh IPv4 ot IPv6 level)
    getprotobyname(): return the protocol the number, for example for TCP
-option_value and option_length [2]: used to pass data used by the particular set command; NULL if no need
    All of the socket-level options except SO_LINGER, SO_RCVTIMEO and SO_SNDTIMEO, expect option_value to point to an integer and option_length to be set to the size of an integer.
    When the integer is nonzero, the option is enabled. When it is zero, the option is disabled
-option_name: single option to set (see [5])
-Return: 0 on success; -1 on failure

    // Reuse port
    int yes=1;
    //char yes='1'; // Solaris people use this

    // lose the pesky "Address already in use" error message
    if (setsockopt(listener,SOL_SOCKET,SO_REUSEADDR,&yes,sizeof yes) == -1) {
        perror("setsockopt");
        exit(1);
    } 

copilot explain:
    The options set by setsockopt() are stored in the operating system's networking subsystem, specifically within the socket data structures maintained by the kernel.

GETSOCKNAME
int getsockname(int sockfd, struct sockaddr *addr, int *addrlen);

stores the current name (addr) for the socket specified by the socket parameter into the structure pointed to by the name (addr) parameter
is often used to discover the port assigned to a socket after the socket has been implicitly bound to a port
To use this function with C++, you must use the _XOPEN_SOURCE_EXTENDED 1 feature test macro
-name (addr): address of the buffer into which getsockname() copies the name of socket.
-namelen (addrlen): must initially point to an integer that contains the size in bytes of the storage pointed to by name
    On return, that integer contains the size required to represent the address of the connecting socket.
    If this value is larger than the size supplied on input, then the information contained in sockaddr is truncated to the length supplied on input.
    If name is NULL, namelen is ignored
-Return: the address to the socket that has been bound; If the socket is not bound to an address, the call returns with the family set, and the rest of the structure set to zero

    struct sockaddr {
        unsigned short sa_family;  // Address family (e.g., AF_INET for IPv4, AF_INET6 for IPv6)
        char sa_data[14];          // Actual socket address data (variable length; contains destination address and port number)
    };

GETPROTOBYNAME
struct protoent *getprotobyname(const char *name);

searches the /etc/protocol or tcpip.ETC.PROTO data set for the specified protocol name
-Return: a pointer to a protoent structure for the network protocol specified on the call; NULL on failure or EOF

The <netdb.h> header shall define the protoent structure, which shall include at least the following members:

    char   *p_name     Official name of the protocol.
    char  **p_aliases  A pointer to an array of pointers to
                        alternative protocol names, terminated by
                        a null pointer.
    int     p_proto    The protocol number.

GETHOSTBYNAME
struct hostent *gethostbyname(const char *name);

tries to resolve the host name through a name server, if one is present. If a name server is not present, gethostbyname() searches the local host tables until a matching host name is found or an EOF marker is reached
-name: is  either  a hostname or an IPv4 address in standard dot notation
Return: returns a pointer to a hostent structure for the host name specified on the call

The <netdb.h> header shall define the hostent structure, which shall include at least the  following members:

    char   *h_name       Official name of the host.
    char  **h_aliases    A pointer to an array of pointers to
                        alternative host names, terminated by a
                        null pointer.
    int     h_addrtype   Address type.
    int     h_length     The length, in bytes, of the address.
    char  **h_addr_list  A pointer to an array of pointers to network
                        addresses (in network byte order) for the host,
                        terminated by a null pointer.

GETADDRINFO [2,3,4]
int getaddrinfo(const char *node,               // e.g. "www.example.com" or IP
                const char *service,            // e.g. "http", "ftp", "telnet", "/etc/services" or port number (e.g 80)
                const struct addrinfo *hints,
                struct addrinfo **res);         // linked list of results

Translates the name of a service location (for example, a host name) and/or service name and returns a set of socket addresses and associated information to be used in creating a socket with which to address the specified service
It used to be that you would use a function called gethostbyname() to do DNS lookups. Then you’d load that information by hand into a struct sockaddr_in, and use that in your calls. This is no longer necessary [4]
getaddrinfo() that does all kinds of good stuff for you, including DNS and service name lookups, and fills out the structs you need [4]
-node and service: either pointers to null-terminated strings or null pointers. One or both of these two arguments must be specified as a non-null pointer
-service: can be a port number, like “80”, or the name of a particular service (found in The IANA Port List20 or the /etc/services file on your Unix machine) like “http” or “ftp” or “telnet” or “smtp” or whatever
    If  service  is  NULL, then the port number of the returned socket addresses will be left uninitialized
-hints: points to a struct addrinfo that you’ve already filled out with relevant information (aka hints)
-Notes: If the caller handles only TCP and not UDP, for example, then the ai_protocol member of the hints structure should be set to IPPROTO_TCP when getaddrinfo() is called.
    If the caller handles only IPV4 and not IPv6, then the ai_family member of the hints structure should be set to AF_INET when getaddrinfo() is called.
    Scope information is only pertinent to IPv6 link-local addresses. It is ignored for resolved IPv4 addresses and IPv6 addresses that are not link-local addresses.
-Returns: returns 0 and a pointer to a linked list of one or more addrinfo structures through the res argument, on success; non-zero error code on failure

    struct addrinfo {
        int              ai_flags;      // AI_PASSIVE (bind the IP of the host), AI_CANONNAME, etc.
        int              ai_family;     // AF_INET, AF_INET6, AF_UNSPEC
        int              ai_socktype;   // SOCK_STREAM, SOCK_DGRAM
        int              ai_protocol;   // use 0 for "any"
        socklen_t        ai_addrlen;    // size of ai_addr in bytes
        struct sockaddr *ai_addr;       // struct sockaddr_in or _in6
        char            *ai_canonname;  // full canonical hostname
        struct addrinfo *ai_next;       // linked list, next node
    };

    // (IPv4 only--see struct sockaddr_in6 for IPv6)

    struct sockaddr_in {
        short int          sin_family;  // Address family, AF_INET
        unsigned short int sin_port;    // Port number
        struct in_addr     sin_addr;    // Internet address
        unsigned char      sin_zero[8]; // Same size as struct sockaddr
    };

    // Internet address (a structure for historical reasons)
    struct in_addr {
        uint32_t s_addr; // that's a 32-bit int (4 bytes)
    };

    // (IPv6 only--see struct sockaddr_in and struct in_addr for IPv4)

    struct sockaddr_in6 {
        u_int16_t       sin6_family;   // address family, AF_INET6
        u_int16_t       sin6_port;     // port number, Network Byte Order
        u_int32_t       sin6_flowinfo; // IPv6 flow information
        struct in6_addr sin6_addr;     // IPv6 address
        u_int32_t       sin6_scope_id; // Scope ID
    };

    struct in6_addr {
        unsigned char   s6_addr[16];   // IPv6 address
    };

    // Usage example
    int s;
    struct addrinfo hints, *res;

    // do the lookup
    // [pretend we already filled out the "hints" struct]
    getaddrinfo("www.example.com", "http", &hints, &res);

    // again, you should do error-checking on getaddrinfo(), and walk
    // the "res" linked list looking for valid entries instead of just
    // assuming the first one is good (like many of these examples do).
    // See the section on client/server for real examples.

    s = socket(res->ai_family, res->ai_socktype, res->ai_protocol);

FREEADDRINFO [2]
void *freeaddrinfo(struct addrinfo *ai);

frees one or more addrinfo structures returned by getaddrinfo(), along with any additional storage associated with those structures. If the ai_next field of the structure is not null, the entire list of structures is freed

BIND [2, 3, 4]
int bind(int sockfd, const struct sockaddr *addr, socklen_t addr_len);

Binds a unique local name (addr) to the socket with descriptor sockfd. After calling socket(), a descriptor does not have an addr associated with it. However, it does belong to a particular address family (name space) as specified when socket() is called. The exact format of a name (addr) depends on the address family
It is normally necessary to assign a local address using bind() before a SOCK_STREAM socket may receive connections (see accept(2))
The  rules  used  in name binding vary between address families
-addr: The pointer to a sockaddr structure containing the name that is to be bound to socket
-addr_len: size of address in bytes
-Return: 0 on success; -1 on failure

Note: when we don’t care about our local port number and we only care where we’re going (the remote port). The kernel will choose a local port for us, and the site we connect to will automatically get this information from us. [4]

CONNECT
int connect(int sockfd,
            const struct sockaddr *addr,    
            socklen_t addr_len);            

For stream sockets, the connect() call attempts to establish a connection between two sockets. For datagram sockets, the connect() call specifies the peer for a socket
The connect() call performs two tasks when called for a stream socket.
First, it completes the binding necessary for a stream socket (in case it has not been previously bound using the bind() call).
Second, it attempts to make a connection to another socket
The connect() call on a stream socket is used by the client application to establish a connection to a server. The server must have a passive open pending
If socket is in blocking mode, the connect() call blocks the caller until the connection is set up, or until an error is received.
If socket is in non-blocking mode, the connect returns immediately with a return code of -1 and an errno of EINPROGRESS.
The caller can test the completion of the connection setup by calling select() and testing for the ability to write to the socket
Stream sockets can call connect() only once, but datagram sockets can call connect() multiple times to change their association
-sockfd: the socket used to originate the connection request
-addr: The pointer to a socket address structure containing the address of the socket to which a connection will be attempted
-addr_len: The size of the socket address pointed to by address in bytes
-Return: 0 on success; -1 on failure

LISTEN [2, 3]
int listen(int sockfd, int backlog);

applies only to stream sockets.
It indicates a readiness to accept client connection requests, and creates a connection request queue of length backlog to queue incoming connection requests.
Once full, additional connection requests are rejected (error ECONNREFUSED or if the protocol suppers retransmission, ignored for later attempt)
It transforms an active socket into a passive socket
Calling listen() is the third of four steps that a server performs to accept a connection. It is called after allocating a stream socket with socket(), and after binding a name to socket with bind(). It must be called before calling accept()
Well, as you can probably imagine, we need to call bind() before we call listen() so that the server is running on a specific port. (You have to be able to tell your buddies which port to connect to!) [4]
-backlog: the maximum length for the queue of pending connections
-Return: 0 on success; -1 on failure

ACCEPT
int accept(int sockfd,
            struct sockaddr *addr,  // output, usually be a pointer to a local struct sockaddr_storage
            socklen_t *addr_len);   // sizeof(struct sockaddr_storage)

Used by a server to accept a connection request from a client. Only with SOCK_STREAM sockets
When a connection is available, the socket created is ready for use to read data from the process that requested the connection
The call accepts the first connection on its queue of pending connections for the given socket socket. 
The accept() call creates a new socket descriptor with the same properties as socket and returns it to the caller.
If the queue has no pending connection requests, accept() blocks the caller unless socket is in nonblocking mode.
If no connection requests are queued and socket is in nonblocking mode, accept() returns -1 and sets the error code to EWOULDBLOCK or EAGAIN.
The new socket descriptor cannot be used to accept new connections. It is not in the listening state
The original socket, sockfd, remains available to accept more connection requests.
A socket can be checked for incoming connection requests using the select(), poll() or epoll() calls
It’ll return to you a brand new socket file descriptor to use for this single connection! That’s right, suddenly you have two socket file descriptors for the price of one! The original one is still listening for more new connections, and the newly created one is finally ready to send() and recv(). We’re there! [4]
-sockfd: a stream socket descriptor created with the socket() call, bound to a local address with bind(2), and is listening for connections
    Is the listen()ing socket descriptor.
-addr: The socket address of the connecting client that is filled in by accept() before it returns
    The format of address is determined by the domain that the client resides in.
    This parameter can be NULL if the caller is not interested in the client address.
    Where the information about the incoming connection will go (and with it you can determine which host is calling you from which port) [4]
-addr_len: Must initially point to an integer that contains the size in bytes of the storage pointed to by address.
    On return, that integer contains the size required to represent the address of the connecting socket.
    If this value is larger than the size supplied on input, then the information contained in sockaddr is truncated to the length supplied on input.
    If address is NULL, addr_len is ignored.
-Return: nonnegative socket descriptor (new_fd) on success; -1 on failure

    struct sockaddr_storage {
        sa_family_t  ss_family;     // address family

        // all this is padding, implementation specific, ignore it:
        char      __ss_pad1[_SS_PAD1SIZE];
        int64_t   __ss_align;
        char      __ss_pad2[_SS_PAD2SIZE];
    };
    // What’s important is that you can see the address family in the ss_family field—check this to see if it’s AF_INET or AF_INET6 (for IPv4 or IPv6). Then you can cast it to a struct sockaddr_in or struct sockaddr_in6 if you wanna [4]

-Note: we will use the socket descriptor new_fd for all send() and recv() calls [4]

HTONS [3]
uint16_t htons(uint16_t hostshort);

Translates a short integer from host byte order to network byte order (big-endian) 
-hostshort: The unsigned short integer to be put into network byte order

HTONL [3]
uint32_t htonl(uint32_t hostlong);

Converts the unsigned short integer hostshort from host byte order to network byte order.
-hostlong: The unsigned integer to be put into network byte order

NTOHS [3]
uint16_t ntohs(uint16_t netshort);

Converts the unsigned short integer netshort from network  byte  order  to host byte order.
-netshort: network unsigned short integer

NTOHL [3]
uint32_t ntohl(uint32_t netlong);

Converts the unsigned integer netlong from network byte order to host byte order
-netshort: network unsigned integer

INET_ADDR [2, 3]
in_addr_t inet_addr(const char *cp);

->obsolete (replaced with inet_pton - "printable to network"); does not work with IPv6

Converts the Internet host address cp from IPv4 numbers-and-dots notation into binary data in network byte order.
If the input is invalid, INADDR_NONE (usually -1) is  returned.
Use  of  this  function  is  problematic  because  -1  is   a   valid   address (255.255.255.255).
Avoid  its  use  in favor of inet_aton(), inet_pton(3), or getaddrinfo(3), which provide a cleaner way to indicate error return.
-Return: the Internet address in network byte order, on success; INADDR_NONE on failure (incorrect format)

INET_NTOA [2, 3]
char *inet_ntoa(struct in_addr in);

->obsolete (replaced with inet_ntop - "network to printable"); does not work with IPv6

Converts the Internet host address in, given in network byte order, to a  string  in  IPv4  dotted-decimal notation (32-bit).
The string is returned in a statically allocated buffer, which subsequent calls will overwrite
-Return: pointer to the Internet address expressed in dotted-decimal notation
    The storage pointed to exists on a per-thread basis (static allocation) and is overwritten by subsequent calls

SEND [3]
ssize_t send(int sockfd, const void *buf, size_t len, int flags);

Sends data on the socket with descriptor socket. The send() call applies to all connected sockets
The send() call may be used only when the socket is in a connected state (so that the  intended recipient is known)
The only difference between send() and write(2) is the presence of flags.
With a zero flags argument, send() is equivalent to write(2).
If  the message is too long to pass atomically through the underlying protocol(!), the error EMSGSIZE is returned, and the message is not transmitted
When  the  message does not fit into the send buffer of the socket, send() normally blocks, unless the socket has been placed in nonblocking I/O mode.
In nonblocking  mode  it  would  fail with the error EAGAIN or EWOULDBLOCK (returns -1) in this case.
The select(2) call may be used to determine when it is possible to send more data.
-sockfd: the socket descriptor you want to send data to (whether it’s the one returned by socket() or the one you got with accept()) [4]
-buf: buffer containing the message to transmit
-len: length of the message
-flags: is the bitwise OR of zero or more of the available flags ([3])
-Return: number of bytes sent (might be less than len you wanted to send), on success; -1 on failure
-Note: if the value returned by send() doesn’t match the value in len, it’s up to you to send the rest of the string. The good news is this: if the packet is small (less than 1K or so) it will probably manage to send the whole thing all in one go [4]

RECV [2, 3]
ssize_t recv(int sockfd, void *buf, size_t len, int flags);

Receives data on a socket and stores it in a buffer.
The recv() call applies only to connected sockets.
The only difference between recv() and read(2) is the presence of flags. With a zero flags argument, recv() is generally equivalent to read(2) (but see NOTES)
If a message is too long to fit in the supplied buffer, excess bytes may be discarded  depending  on  the  type  of socket the message is received from.
If no messages are available at the socket, the receive calls wait for a message to arrive, unless the socket is nonblocking (see fcntl(2)), in which case the value -1 is returned  and  the external variable errno is set to EAGAIN or EWOULDBLOCK.
The receive calls normally return any data available, up to the requested amount, rather than waiting for receipt of the full  amount requested.
An application can use select(2), poll(2), or epoll(7) to determine when more data arrives on a socket
The flags argument is formed by ORing one or more of the available values ([3])
-sockfd: the socket descriptor to read from
-buf: the buffer to read the information into
-len: the maximum length of the buffer
-flags: can be 0
-Return: number of bytes received (0 for EOF or len=0; the remote side has closed the connection! [4]), on success; -1 on failure

SIGNAL [3]
void(*signal(int sig, void(*func)(int)))(int);
or:
typedef void (*sighandler_t)(int);
sighandler_t signal(int signum, sighandler_t handler);

SIGACTION [3]
int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);

The sigaction structure is defined as something like:

    struct sigaction {
        void     (*sa_handler)(int);
        void     (*sa_sigaction)(int, siginfo_t *, void *);
        sigset_t   sa_mask;
        int        sa_flags;
        void     (*sa_restorer)(void);
    };
When the SA_SIGINFO flag is specified in act.sa_flags, the signal handler address is passed via the act.sa_sigaction field.  This handler takes three arguments, as follows:

    void
    handler(int sig, siginfo_t *info, void *ucontext)
    {
        ...
    }

LSEEK [3]
off_t lseek(int fd, off_t offset, int whence);

Repositions  the file offset of the open file description associated with the file descriptor fd to the argument offset according to the directive whence as follows
lseek() allows the file offset to be set beyond the end of the file (but this does  not  change the size of the file).  If data is later written at this point, subsequent reads of the data in the gap (a "hole") return null bytes ('\0') until data is actually written into the gap
-whence:
    SEEK_SET (The file offset is set to offset bytes)
    SEEK_CUR (The file offset is set to its current location plus offset bytes)
    SEEK_END (The file offset is set to the size of the file plus offset bytes)
    SEEK_DATA (Adjust the file offset to the next location in the file greater than or equal to  offset containing data.  If offset points to data, then the file offset is set to offset.)
    SEEK_HOLE (Adjust the file offset to the next hole in the file greater than or equal to offset.  If offset points into the middle of a hole, then the file offset  is  set  to  offset.   If there  is  no  hole past offset, then the file offset is adjusted to the end of the file (i.e., there is an implicit hole at the end of any file))
-Return: the resulting offset location as measured in  bytes from the beginning of the file, on success; -1 on failure

FSTAT [3]
int fstat(int fd, struct stat *statbuf);

Retrieves information about the file descriptor fd
Returns a stat structure, which contains the following fields:
    struct stat {
        dev_t     st_dev;         /* ID of device containing file */
        ino_t     st_ino;         /* Inode number */
        mode_t    st_mode;        /* File type and mode */
        nlink_t   st_nlink;       /* Number of hard links */
        uid_t     st_uid;         /* User ID of owner */
        gid_t     st_gid;         /* Group ID of owner */
        dev_t     st_rdev;        /* Device ID (if special file) */
        off_t     st_size;        /* Total size, in bytes */
        blksize_t st_blksize;     /* Block size for filesystem I/O */
        blkcnt_t  st_blocks;      /* Number of 512B blocks allocated */

        /* Since Linux 2.6, the kernel supports nanosecond
            precision for the following timestamp fields.
            For the details before Linux 2.6, see NOTES. */

        struct timespec st_atim;  /* Time of last access */
        struct timespec st_mtim;  /* Time of last modification */
        struct timespec st_ctim;  /* Time of last status change */

    #define st_atime st_atim.tv_sec      /* Backward compatibility */
    #define st_mtime st_mtim.tv_sec
    #define st_ctime st_ctim.tv_sec
    };
-Return: 0 on success; -1 on failure

FCNTL [2,3]
int fcntl(int fd, int cmd, ... /* arg */ );

Performs one of the operations described below on the open file descriptor fd.  The operation is determined by cmd
fcntl() can take an optional third argument.  Whether or not this argument is required  is  determined  by  cmd.   The required argument type is indicated in parentheses after each cmd name ( most cases, the required type is int, and we identify the argument using the name arg), or void is specified if the argument is not required.
Lots of functions block (aka sleep). accept() blocks. All the recv() functions block. The reason they can do this is because they’re allowed to. When you first create the socket descriptor with socket(), the kernel sets it to blocking. If you don’t want a socket to be blocking, you have to make a call to fcntl() [4]
-cmd: (examples)
    F_SETFL (int): Set the file status flags to the value specified by arg
        On Linux, this command can change only the  O_APPEND,  O_ASYNC,  O_DIRECT,  O_NOATIME,  and  O_NONBLOCK  flags
    F_SETSIG (int): Set the signal sent when input or output becomes possible to the value given in arg
        A value of zero means to send the default SIGIO signal.  Any other value (including SIGIO) is the signal to send instead, and in this case additional info is available to the signal handler if installed with SA_SIGINFO

POLL (or equivalent, such as select(), kqueue() or epoll()-linux-)

POLL
int poll(struct pollfd *fds, nfds_t nfds, int timeout);

Multiplexing
Performs  a similar task to select(2): it waits for one of a set of file descriptors to become ready to perform I/O.
If you try to read from a non-blocking socket and there’s no data there, it’s not allowed to block—it will return -1 and errno will be set to EAGAIN or EWOULDBLOCK. Check for both, for portability. The output is system dependent. This is not CPU efficient, as the program is put in a busy-wait mode. Use Poll instead! [4]
The bits that may be set/returned in events and revents are defined in <poll.h>
    POLLIN There is data to read (recv())
    POLLPRI There is some exceptional condition on the file descriptor (out-of-band data on a TCP socket, tcp(7))
    POLLOUT Writing (send())  is  now possible, though a write larger that the available space in a socket or pipe will still block (unless O_NONBLOCK is set)
    POLLRDHUP Stream socket peer closed connection, or shut down  writing  half  of  connection
    POLLERR Error condition (only returned in revents; ignored in events). This bit is also set for a  file  descriptor  referring  to  the  write  end of a pipe when the read end has been closed.
    POLLHUP Hang up (only returned in revents; ignored in events). Note that when  reading  from  a channel  such  as  a  pipe or a stream socket, this event merely indicates that the peer closed its end of the channel.  Subsequent reads from the channel will return 0 (EOF) only after all outstanding data in the channel has been consumed
    POLLNVAL Invalid request: fd not open (only returned in revents; ignored in events).
    When  compiling with _XOPEN_SOURCE defined, one also has the following:
    POLLRDNORM =POLLIN
    POLLRDBAND Priority band data can be read (generally unused on Linux)
    POLLWRNORM =POLLOUT
    POLLWRBAND Priority data may be written
The OS will block on the poll() call until one of those events occurs (e.g. “socket ready to read!”) or until a user-specified timeout occurs [4]
After poll() returns, you can check the revents field to see if POLLIN or POLLOUT is set, indicating that event occurred.
-fds: set (array) of file descriptors (sockets) to be monitored
    Add file descriptors: simply make sure you have enough space in the array for all you need, or realloc() more space as needed [4]
    Remove file descriptores: you can copy the last element in the array over-top the one you’re deleting. And then pass in one fewer as the count to poll(). Another option is that you can set any fd field to a negative number and poll() will ignore it [4]

    struct pollfd {
               int   fd;         /* file descriptor (socket) for open file */
               short events;     /* requested events (bitmap) */
               short revents;    /* returned events (bitmap, on return) */
           };

    .fd
        If this field is negative, then the corresponding events field is ignored and the revents field returns zero
    .events
        Is an input parameter. A bit mask specifying the events the application is interested in for the file descriptor fd.  This field may be specified as zero, in which case the only events that can be returned in revents are POLLHUP, POLLERR, and POLLNVAL
    .revents
        Is an output parameter. Filled by the kernel with the  events  that  actually occurred.  The bits returned in revents can include any of those specified in events, or one of the values POLLERR, POLLHUP, or POLLNVAL.  (These three bits  are  meaningless  in  the  events field, and will be set in the revents field whenever the corresponding condition is true.)
-nfds: number of items in the fds array in nfds
-timeout: the number of milliseconds that poll() should block waiting  for a file descriptor to become ready.
    The call will block until either:
        *  a file descriptor becomes ready;
        *  the call is interrupted by a signal handler; or
        *  the timeout expires.
    Specifying  a negative  value  in  timeout  means  an  infinite timeout.
    Specifying a timeout of zero causes poll() to return immediately, even if no file descriptors are ready.
-Returns:
    >0, on success; number of structures which have  nonzero revents  fields (in other words, those descriptors with events or errors reported)
    0: the call timed out and no file descriptors were ready
    -1, on failure

SELECT
int select(int nfds, fd_set *readfds, fd_set *writefds,
                  fd_set *exceptfds, struct timeval *timeout);

Allows a program to monitor multiple file descriptors, waiting until one or more of the file descriptors become "ready" for some class of  I/O  operation  (e.g.,  input possible).
A file descriptor is considered ready if it is possible to perform a corresponding I/O operation (e.g., read(2), or a sufficiently small write(2)) without blocking
select() can monitor only file descriptors numbers that are less than FD_SETSIZE; poll(2) does not have this limitation.

EPOLL
The  epoll  API performs a similar task to poll(2): monitoring multiple file descriptors to see if I/O is possible on any of them.
The epoll API can be used either as an edge-triggered or  a level-triggered interface (=poll()) and scales well to large numbers of watched file descriptors

ABBREVIATIONS
    DNS (Domain Name System)
        Hierarchical and decentralized naming system that translates human-readable domain names into numerical IP addresses
    
    NAT (Network Address Translation)
        Lots of places have a firewall that hides the network from the rest of the world for their own protection. And often times, the firewall translates “internal” IP addresses to “external” (that everyone else in the world knows) IP addresses using NAT
    
    ISP (Internet Service Provider)

    DSL (Digital Subscriber Line)
        A technology that provides high-speed internet access over traditional copper telephone lines
    
    IANA (Internet Assigned Numbers Authority)
        A key organization responsible for the management of certain aspects of the DNS, IP address allocation, and protocol parameter assignment

    RFC (Request for Comments)
        Is a series of documents that describe various aspects of the internet, including its protocols, procedures, programs, and concepts. The RFC series is one of the fundamental building blocks of the internet's technical specifications and standards
    
    
REFERENCES:
[1] https://www.geeksforgeeks.org/socket-programming-cc/
[2] https://www.ibm.com/docs/en/zos/2.1.0?topic=functions-socket-create-socket
[3] man
[4] https://beej.us/guide/bgnet/html/#structs
[5] https://pubs.opengroup.org/onlinepubs/7908799/xns/setsockopt.html
